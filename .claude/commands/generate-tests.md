---
description: Generate xUnit tests for C# code
allowed-tools: ["Read", "Write", "Glob", "Grep"]
argument-hint: "<file-or-class-name>"
---

Generate comprehensive xUnit tests for the specified code.

## Target
$ARGUMENTS

## TDD Mindset

When generating tests, think about:
1. **What behavior should this code have?**
2. **What are the edge cases?**
3. **What should happen with invalid inputs?**
4. **What are the failure modes?**

If the implementation doesn't exist yet, that's GOOD - write the tests first!

## Test Generation Guidelines

### Test Structure
- One test class per production class
- Use `ClassNameTests` naming convention
- Organize with nested classes for method groupings if needed
- Follow Arrange-Act-Assert pattern

### Test Categories (in order of priority)
1. **Happy Path Tests** - Normal expected behavior
2. **Edge Cases** - Boundary conditions, empty inputs, null values
3. **Error Cases** - Invalid inputs, exceptions expected
4. **Integration Points** - Mock external dependencies

### xUnit Patterns
```csharp
[Fact]
public void MethodName_WhenCondition_ShouldExpectedResult()
{
    // Arrange - Set up test data and dependencies

    // Act - Execute the method under test

    // Assert - Verify the outcome
}

[Theory]
[InlineData("input1", "expected1")]
[InlineData("input2", "expected2")]
[InlineData("", null)]  // Edge case
public void MethodName_WithVariousInputs_ReturnsExpected(string input, string? expected)
{
    // Arrange & Act & Assert
}
```

### Mocking with NSubstitute
```csharp
// Create mock
var mockService = Substitute.For<IService>();

// Setup return value
mockService.GetValue(Arg.Any<string>()).Returns("result");

// Verify method was called
mockService.Received(1).GetValue("expected-arg");

// Verify method was NOT called
mockService.DidNotReceive().OtherMethod();
```

### Assertions with FluentAssertions
```csharp
// Value assertions
result.Should().Be(expected);
result.Should().NotBeNull();
result.Should().BeGreaterThan(0);

// Collection assertions
items.Should().HaveCount(3);
items.Should().Contain(x => x.Name == "Test");
items.Should().BeInAscendingOrder(x => x.Id);

// Exception assertions
var act = () => sut.Method(invalidInput);
act.Should().Throw<ArgumentException>()
   .WithMessage("*expected*")
   .WithParameterName("paramName");

// Async exception assertions
var act = async () => await sut.MethodAsync(invalidInput);
await act.Should().ThrowAsync<InvalidOperationException>();

// Object comparison
result.Should().BeEquivalentTo(expected);
```

### Test Data with AutoFixture
```csharp
[Theory, AutoData]
public void Method_WithAutoGeneratedData_Works(string input, int value)
{
    // AutoFixture generates random test data
}

// Custom fixture for complex objects
var fixture = new Fixture();
fixture.Customize<MyClass>(c => c.With(x => x.Property, "fixed-value"));
var instance = fixture.Create<MyClass>();
```

## Test Checklist
- [ ] Constructor validation tests (null checks)
- [ ] Happy path for each public method
- [ ] Edge cases (empty, null, boundary values)
- [ ] Exception scenarios
- [ ] Async methods tested with async/await
- [ ] Dependencies properly mocked
